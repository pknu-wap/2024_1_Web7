{"ast":null,"code":"import { getKeys } from \"./chunk-4MXCHP7N.mjs\";\nimport { getUncontrolledKey, makeUncontrolledKeyMap } from \"./chunk-SI4FST6P.mjs\";\nimport { omitUndefined } from \"./chunk-RVDAKL7Q.mjs\";\nimport { useNavermaps } from \"./chunk-SENI7KNJ.mjs\";\nimport { HandleEvents } from \"./chunk-533MYCRP.mjs\";\nimport { Overlay } from \"./chunk-IV7GZJYG.mjs\";\n\n// src/overlays/marker.tsx\nimport mapKeys from \"lodash.mapkeys\";\nimport pick from \"lodash.pick\";\nimport { forwardRef, useLayoutEffect, useImperativeHandle, useRef, useState } from \"react\";\nimport { useFirstMountState } from \"react-use\";\nimport { jsx } from \"react/jsx-runtime\";\nvar primitiveKeys = [\"animation\", \"icon\", \"shape\", \"title\", \"cursor\", \"clickable\", \"draggable\", \"visible\", \"zIndex\"];\nvar locationalKeys = [\"position\"];\nvar uncontrolledKeyMap = makeUncontrolledKeyMap(locationalKeys);\nvar kvoKeys = [...primitiveKeys, ...locationalKeys];\nvar kvoEvents = kvoKeys.map(key => `${key}_changed`);\nvar uiEvents = [\"mousedown\", \"mouseup\", \"click\", \"dblclick\", \"rightclick\", \"mouseover\", \"mouseout\", \"dragstart\", \"drag\", \"dragend\"];\nvar events = [...uiEvents, ...kvoEvents];\nfunction makeInitialOption(props) {\n  const uncontrolledProps = pick(props, getKeys(uncontrolledKeyMap));\n  const prefixCleared = mapKeys(uncontrolledProps, (_, key) => uncontrolledKeyMap[key]);\n  const kvoProps = pick(props, kvoKeys);\n  return omitUndefined({\n    ...kvoProps,\n    ...prefixCleared\n  });\n}\nfunction isLocationalKey(key) {\n  return locationalKeys.includes(key);\n}\nfunction isEqualKvo(kvo, target) {\n  if (kvo === void 0) {\n    return false;\n  }\n  if (kvo === target) {\n    return true;\n  }\n  try {\n    return kvo.equals(target);\n  } catch {\n    return kvo === target;\n  }\n}\nvar Marker = forwardRef(function Marker2(props, ref) {\n  const navermaps = useNavermaps();\n  const [marker] = useState(() => new navermaps.Marker(makeInitialOption(props)));\n  useImperativeHandle(ref, () => marker);\n  const isFirst = useFirstMountState();\n  const dirtiesRef = useRef({});\n  dirtiesRef.current = getDirties();\n  function getDirties() {\n    if (isFirst) {\n      return {};\n    }\n    return kvoKeys.reduce((acc, key) => {\n      if (props[key] === void 0) {\n        return acc;\n      }\n      if (isLocationalKey(key) && props[getUncontrolledKey(key)] !== void 0) {\n        return acc;\n      }\n      const kvos = marker.getOptions(key);\n      if (isEqualKvo(kvos[key], props[key])) {\n        return acc;\n      }\n      return {\n        ...acc,\n        [key]: props[key]\n      };\n    }, {});\n  }\n  function pickDirties(keys) {\n    return pick(dirtiesRef.current, keys);\n  }\n  useLayoutEffect(() => {\n    const {\n      position\n    } = pickDirties([\"position\"]);\n    if (position) {\n      marker.setPosition(position);\n    }\n  }, [dirtiesRef.current[\"position\"]]);\n  useLayoutEffect(() => {\n    const dirties = pickDirties(primitiveKeys);\n    if (Object.values(dirties).length < 1) {\n      return;\n    }\n    marker.setOptions(dirties);\n  }, primitiveKeys.map(key => dirtiesRef.current[key]));\n  return /* @__PURE__ */jsx(Overlay, {\n    element: marker,\n    children: /* @__PURE__ */jsx(HandleEvents, {\n      events,\n      listeners: props\n    })\n  });\n});\nexport { Marker };","map":{"version":3,"names":["mapKeys","pick","forwardRef","useLayoutEffect","useImperativeHandle","useRef","useState","useFirstMountState","jsx","primitiveKeys","locationalKeys","uncontrolledKeyMap","makeUncontrolledKeyMap","kvoKeys","kvoEvents","map","key","uiEvents","events","makeInitialOption","props","uncontrolledProps","getKeys","prefixCleared","_","kvoProps","omitUndefined","isLocationalKey","includes","isEqualKvo","kvo","target","equals","Marker","Marker2","ref","navermaps","useNavermaps","marker","isFirst","dirtiesRef","current","getDirties","reduce","acc","getUncontrolledKey","kvos","getOptions","pickDirties","keys","position","setPosition","dirties","Object","values","length","setOptions","Overlay","element","children","HandleEvents","listeners"],"sources":["C:\\GitHub\\2024_1_Web7\\node_modules\\react-naver-maps\\src\\overlays\\marker.tsx"],"sourcesContent":["import mapKeys from 'lodash.mapkeys';\nimport pick from 'lodash.pick';\nimport { forwardRef, useLayoutEffect, useImperativeHandle, useRef, useState } from 'react';\nimport { useFirstMountState } from 'react-use';\n\nimport { HandleEvents } from '../helpers/event';\nimport { Overlay } from '../overlay';\nimport type { UIEventHandlers } from '../types/event';\nimport { useNavermaps } from '../use-navermaps';\nimport { getKeys } from '../utils/get-keys';\nimport { omitUndefined } from '../utils/omit-undefined';\nimport { getUncontrolledKey, makeUncontrolledKeyMap, UncontrolledKey } from '../utils/uncontrolled';\n\nconst primitiveKeys = [\n  'animation',\n  'icon',\n  'shape',\n  'title',\n  'cursor',\n  'clickable',\n  'draggable',\n  'visible',\n  'zIndex',\n] as const;\nconst locationalKeys = ['position'] as const;\nconst uncontrolledKeyMap = makeUncontrolledKeyMap(locationalKeys);\nconst kvoKeys = [\n  ...primitiveKeys,\n  ...locationalKeys,\n] as const;\nconst kvoEvents = kvoKeys.map(key => `${key}_changed`);\nconst uiEvents = [\n  'mousedown',\n  'mouseup',\n  'click',\n  'dblclick',\n  'rightclick',\n  'mouseover',\n  'mouseout',\n  'dragstart',\n  'drag',\n  'dragend',\n] as const;\nconst events = [...uiEvents, ...kvoEvents];\n\ntype MarkerKVO = {\n  /** Animation??? */\n  animation: naver.maps.Animation;\n  position: naver.maps.Coord | naver.maps.CoordLiteral;\n  icon: string | naver.maps.ImageIcon | naver.maps.SymbolIcon | naver.maps.HtmlIcon;\n  shape: naver.maps.MarkerShape;\n  title: string;\n  cursor: string;\n  clickable: boolean;\n  draggable: boolean;\n  visible: boolean;\n  zIndex: number;\n};\n\ntype UncontrolledProps = {\n  [key in typeof locationalKeys[number] as UncontrolledKey<key>]: MarkerKVO[key];\n};\n\n// TODO: Fix DefinitelyTyped\ntype MarkerOptions = Partial<MarkerKVO>;\n\nexport type Props = MarkerOptions & Partial<UncontrolledProps> & UIEventHandlers<typeof uiEvents> & {\n  onAnimationChanged?: (value: naver.maps.Animation) => void;\n  onPositionChanged?: (value: naver.maps.Coord) => void;\n  onIconChanged?: (value: string | naver.maps.ImageIcon | naver.maps.HtmlIcon | naver.maps.SymbolIcon) => void;\n  onShapeChanged?: (event: naver.maps.MarkerShape) => void;\n  onTitleChanged?: (event: string) => void;\n  onCursorChanged?: (event: string) => void;\n  onClickableChanged?: (event: boolean) => void;\n  onDraggableChanged?: (event: boolean) => void;\n  onVisibleChanged?: (event: boolean) => void;\n  /**\n   * hello yeah\n   * @param event helo?\n   * @returns\n   */\n  onZIndexChanged?: (event: number) => void;\n};\n\nfunction makeInitialOption(props: Props) {\n  const uncontrolledProps = pick(props, getKeys(uncontrolledKeyMap));\n  const prefixCleared = mapKeys(uncontrolledProps, (_, key) => uncontrolledKeyMap[key as keyof typeof uncontrolledKeyMap]);\n  const kvoProps = pick(props, kvoKeys);\n\n  return omitUndefined({ ...kvoProps, ...prefixCleared });\n}\n\nfunction isLocationalKey(key: string): key is typeof locationalKeys[number] {\n  return locationalKeys.includes(key as typeof locationalKeys[number]);\n}\n\nfunction isEqualKvo(kvo: any, target: any) {\n  if (kvo === undefined) {\n    return false;\n  }\n\n  if (kvo === target) {\n    return true;\n  }\n\n  try {\n    return kvo.equals(target);\n  } catch {\n    return kvo === target;\n  }\n}\n\nexport const Marker = forwardRef<naver.maps.Marker, Props>(function Marker(props, ref) {\n  const navermaps = useNavermaps();\n  const [marker] = useState(() => new navermaps.Marker(makeInitialOption(props)));\n  useImperativeHandle<naver.maps.Marker | undefined, naver.maps.Marker | undefined>(ref, () => marker);\n\n  // make dirties\n  const isFirst = useFirstMountState();\n  const dirtiesRef = useRef<Pick<Props, typeof kvoKeys[number]>>({});\n  dirtiesRef.current = getDirties();\n\n  function getDirties() {\n    // initialize의 option과 중복되지 않도록 첫 렌더시 제외한다.\n    if (isFirst) {\n      return {};\n    }\n\n    return kvoKeys.reduce((acc, key) => {\n      if (props[key] === undefined) {\n        return acc;\n      }\n\n      if (isLocationalKey(key) && props[getUncontrolledKey(key)] !== undefined) {\n        return acc;\n      }\n\n      const kvos = marker.getOptions(key);\n      if (isEqualKvo(kvos[key], props[key])) {\n        return acc;\n      }\n\n      return {\n        ...acc,\n        [key]: props[key],\n      };\n    }, {});\n  }\n\n  function pickDirties(keys: readonly string[]) {\n    return pick(dirtiesRef.current, keys);\n  }\n\n  // side effects\n  useLayoutEffect(() => {\n    const { position } = pickDirties(['position']);\n    if (position) {\n      marker.setPosition(position);\n    }\n  }, [dirtiesRef.current['position']]);\n\n  useLayoutEffect(() => {\n    const dirties = pickDirties(primitiveKeys);\n    if (Object.values(dirties).length < 1) {\n      return;\n    }\n\n    marker.setOptions(dirties);\n  }, primitiveKeys.map(key => dirtiesRef.current[key]));\n\n  return (\n    <Overlay element={marker}>\n      <HandleEvents events={events} listeners={props as any} />\n    </Overlay>\n  );\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}